<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Stochastic Light Cuts</title>
  <script type="module" crossorigin>(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&n(c)}).observe(document,{childList:!0,subtree:!0});function r(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(i){if(i.ep)return;i.ep=!0;const o=r(i);fetch(i.href,o)}})();function re(e){const t=new Float32Array(16);return t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15],t}function oe(e){const t=new Float32Array(16),r=e[0],n=e[1],i=e[2],o=e[3],c=e[4],a=e[5],l=e[6],s=e[7],u=e[8],d=e[9],f=e[10],b=e[11],g=e[12],h=e[13],v=e[14],w=e[15],U=r*a-n*c,R=r*l-i*c,M=r*s-o*c,L=n*l-i*a,B=n*s-o*a,G=i*s-o*l,F=u*h-d*g,O=u*v-f*g,_=u*w-b*g,I=d*v-f*h,A=d*w-b*h,C=f*w-b*v;let P=U*C-R*A+M*I+L*_-B*O+G*F;return P&&(P=1/P,t[0]=(a*C-l*A+s*I)*P,t[1]=(-n*C+i*A-o*I)*P,t[2]=(h*G-v*B+w*L)*P,t[3]=(-d*G+f*B-b*L)*P,t[4]=(-c*C+l*_-s*O)*P,t[5]=(r*C-i*_+o*O)*P,t[6]=(-g*G+v*M-w*R)*P,t[7]=(u*G-f*M+b*R)*P,t[8]=(c*A-a*_+s*F)*P,t[9]=(-r*A+n*_-o*F)*P,t[10]=(g*B-h*M+w*U)*P,t[11]=(-u*B+d*M-b*U)*P,t[12]=(-c*I+a*O-l*F)*P,t[13]=(r*I-n*O+i*F)*P,t[14]=(-g*L+h*R-v*U)*P,t[15]=(u*L-d*R+f*U)*P),t}function Ae(e,t,r,n){const i=1/Math.tan(e*.5),o=1/(r-n);return new Float32Array([i/t,0,0,0,0,i,0,0,0,0,n*o,-1,0,0,r*n*o,0])}function Ce(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}function ce(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}function Ie(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}function le(e){const t=Ce(e);return[e[0]/t,e[1]/t,e[2]/t]}function pe(e){return[e.target[0]+e.radius*Math.cos(e.pitch)*Math.sin(e.yaw),e.target[1]+e.radius*Math.sin(e.pitch),e.target[2]+e.radius*Math.cos(e.pitch)*Math.cos(e.yaw)]}function be(e,t,r){const n=Math.cos(e.yaw),i=Math.sin(e.yaw),o=n,c=-i,a=e.radius*e.panSpeed;e.target[0]+=(-o*t+0*r)*a,e.target[1]+=(0*t+1*r)*a,e.target[2]+=(-c*t+0*r)*a}function De(e,t,r,n){const i=t[0]-r[0],o=t[1]-r[1],c=t[2]-r[2];let a=1/Math.sqrt(i*i+o*o+c*c);const l=i*a,s=o*a,u=c*a;let d=n[1]*u-n[2]*s,f=n[2]*l-n[0]*u,b=n[0]*s-n[1]*l;a=1/Math.sqrt(d*d+f*f+b*b);const g=d*a,h=f*a,v=b*a,w=s*v-u*h,U=u*g-l*v,R=l*h-s*g;e[0]=g,e[1]=w,e[2]=l,e[3]=0,e[4]=h,e[5]=U,e[6]=s,e[7]=0,e[8]=v,e[9]=R,e[10]=u,e[11]=0,e[12]=-(g*t[0]+h*t[1]+v*t[2]),e[13]=-(w*t[0]+U*t[1]+R*t[2]),e[14]=-(l*t[0]+s*t[1]+u*t[2]),e[15]=1}function ae(e){e.viewMat=new Float32Array(16);const t=pe(e);De(e.viewMat,t,e.target,[0,1,0]),e.invViewMat=oe(e.viewMat),e.transInvViewMat=re(e.invViewMat),e.projMat=Ae(e.fov,e.aspect,e.near,e.far),e.modelMat=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Oe(e){const t={viewMat:new Float32Array(16),invViewMat:new Float32Array(16),transInvViewMat:new Float32Array(16),projMat:new Float32Array(16),modelMat:new Float32Array(16),fov:Math.PI/4,aspect:e,near:.1,far:100,yaw:0,pitch:0,radius:3,target:[0,0,0],rotateSpeed:.005,panSpeed:.001,zoomSpeed:.001,minRadius:.5,maxRadius:20};return ae(t),t}function _e(e){const t=e.indices.length/3,r=e.normals.length;for(let n=0;n<r;++n)e.normals[n]=0;for(let n=0;n<t;++n){const i=e.indices[3*n],o=e.indices[3*n+1],c=e.indices[3*n+2],a=[e.positions[3*i],e.positions[3*i+1],e.positions[3*i+2]],l=[e.positions[3*o],e.positions[3*o+1],e.positions[3*o+2]],s=[e.positions[3*c],e.positions[3*c+1],e.positions[3*c+2]],u=ce(l,a),d=ce(s,l),f=le(Ie(u,d)),b=[i,o,c];for(let g=0;g<3;g++){const h=b[g];e.normals[3*h]=e.normals[3*h]+f[0],e.normals[3*h+1]=e.normals[3*h+1]+f[1],e.normals[3*h+2]=e.normals[3*h+2]+f[2]}}for(let n=0;n<r/3;++n){const i=[e.normals[3*n],e.normals[3*n+1],e.normals[3*n+2]],o=le(i);e.normals[3*n]=o[0],e.normals[3*n+1]=o[1],e.normals[3*n+2]=o[2]}}function ye(e){const t=[],r=[],n=[],i=[null];let o="";const c=e.split(/\r?\n/);for(let a of c){if(a=a.trim(),!a||a.startsWith("#"))continue;const l=a.split(/\s+/),s=l[0];if(s==="v"){if(l.length<4)continue;const u=Number(l[1]),d=Number(l[2]),f=Number(l[3]);i.push([u,d,f])}else if(s==="usemtl")o=l[1]||"";else if(s==="f"){if(l.length<4)continue;const u=[];for(let d=1;d<l.length;d++){const f=l[d];if(!f)continue;const b=f.split("/")[0];let g=parseInt(b,10);Number.isNaN(g)||(g<0&&(g=i.length+g),u.push(g))}if(u.length<3)continue;for(let d=1;d<u.length-1;d++){const f=u[0],b=u[d],g=u[d+1];if(r.push(f-1,b-1,g-1),o==="RamLight"){const h=i[f],v=i[b],w=i[g];h&&v&&w&&n.push([(h[0]+v[0]+w[0])/3,(h[1]+v[1]+w[1])/3,(h[2]+v[2]+w[2])/3])}}}}for(let a=1;a<i.length;a++){const l=i[a];t.push(l[0],l[1],l[2])}return{positions:t,indices:r,lightPositions:n}}function ve(e,t){if(e==="ram"&&t.length>0){const r=[];for(let n=0;n<t.length;n+=2){const i=t[n],o=t[n+1]??i;r.push([.5*(i[0]+o[0]),.5*(i[1]+o[1]),.5*(i[2]+o[2])])}return console.log("[OBJ] Compressed RAM light triangles:",t.length,"->",r.length),r}return t}async function Ve(e,t=0){const r=`data/scenes/${e}/${e}.obj`;console.log("[OBJ] Loading scene from",r);const n=await fetch(r);if(!n.ok)throw new Error(`[OBJ] Failed to load OBJ for scene "${e}": HTTP ${n.status}`);const i=await n.text();let{positions:o,indices:c,lightPositions:a}=ye(i);a=ve(e,a),!o.length||!c.length?console.warn("[OBJ] Parsed empty geometry for scene",e):console.log("[OBJ] Parsed scene",e,"vertices =",o.length/3,"triangles =",c.length/3,"lightTriangles =",a.length);const l={positions:new Float32Array(o),normals:new Float32Array(o.length),indices:new Uint32Array(c),materialIndex:t};return _e(l),{meshes:[l],lights:a}}async function Ne(e,t="lights"){const r=`data/scenes/${e}/${t}.obj`;console.log("[OBJ] Loading separate lights from",r);let n;try{n=await fetch(r)}catch(c){return console.warn("[OBJ] Failed to fetch separate lights OBJ for scene",e,c),[]}if(!n.ok)return console.log("[OBJ] No separate lights OBJ found for scene",e,"- HTTP",n.status),[];const i=await n.text();let{lightPositions:o}=ye(i);return o=ve(e,o),console.log("[OBJ] Parsed separate lights for scene",e,"count =",o.length),o}async function Ye(e){const t=`data/scenes/${e}/${e}.mtl`;console.log("[Scene] Loading materials from",t);try{const r=await fetch(t);if(!r.ok)throw new Error(`HTTP ${r.status}`);const i=(await r.text()).split(/\r?\n/),o=[];let c=null;for(const l of i){const s=l.trim();if(!s||s.startsWith("#"))continue;const u=s.split(/\s+/),d=u[0];if(d==="newmtl"){const f=u[1]||"";c={name:f,albedo:[.8,.8,.8],roughness:.5,metalness:0},/light$/i.test(f)||o.push(c)}else if(d==="Kd"&&c){const f=Number(u[1]),b=Number(u[2]),g=Number(u[3]);!Number.isNaN(f)&&!Number.isNaN(b)&&!Number.isNaN(g)&&(c.albedo=[f,b,g])}}o.length||(console.warn("[Scene] No non-light materials found in MTL, using default."),o.push({name:"Default",albedo:[.8,.8,.8],roughness:.5,metalness:0}));const a=o.map(l=>({albedo:l.albedo,roughness:l.roughness,metalness:l.metalness}));return console.log("[Scene] Parsed MTL materials:",o),a}catch(r){return console.error("[Scene] Failed to load MTL materials, using fallback.",r),[{albedo:[.8,.8,.8],roughness:.5,metalness:0}]}}function j(e){let t=1/0,r=1/0,n=1/0,i=-1/0,o=-1/0,c=-1/0,a=!1;for(const l of e){if(!l.positions||l.positions.length<3)continue;a=!0;const s=l.positions;for(let u=0;u<s.length;u+=3){const d=s[u],f=s[u+1],b=s[u+2];d<t&&(t=d),f<r&&(r=f),b<n&&(n=b),d>i&&(i=d),f>o&&(o=f),b>c&&(c=b)}}return a?{minX:t,minY:r,minZ:n,maxX:i,maxY:o,maxZ:c}:null}function qe(e){if(!e.meshes||e.meshes.length===0){e.camera.target=[0,.5,0],e.camera.radius=4*.5;return}const t=j(e.meshes);if(!t)return;const r=[.5*(t.minX+t.maxX),.5*(t.minY+t.maxY),.5*(t.minZ+t.maxZ)];let n=0;for(const o of e.meshes){if(!o.positions||o.positions.length<3)continue;const c=o.positions;for(let a=0;a<c.length;a+=3){const l=c[a]-r[0],s=c[a+1]-r[1],u=c[a+2]-r[2],d=l*l+s*s+u*u;d>n&&(n=d)}}const i=Math.max(Math.sqrt(n),.1);e.camera.target=r,e.camera.radius=Math.min(Math.max(i*2.5,e.camera.minRadius*2),Math.max(e.camera.maxRadius,i*4)),e.camera.maxRadius=Math.max(e.camera.maxRadius,i*4),e.camera.near=Math.max(i/100,.01),e.camera.far=Math.max(i*10,e.camera.near*10)}async function ze(e){const t=`data/scenes/${e}/camera.txt`;try{const r=await fetch(t);if(!r.ok)return null;const n=await r.text(),i={};for(const o of n.split(/\r?\n/)){const c=o.trim();if(!c||c.startsWith("#"))continue;const a=c.indexOf("=");if(a<=0)continue;const l=c.slice(0,a).trim(),s=c.slice(a+1).trim(),u=Number(s);i[l]=Number.isNaN(u)?s:u}return Object.keys(i).length===0?null:i}catch{return null}}function Xe(e,t){t.radiusScale!=null&&(e.camera.radius*=t.radiusScale,e.camera.radius=Math.max(e.camera.minRadius,Math.min(e.camera.maxRadius,e.camera.radius))),t.radius!=null&&(e.camera.radius=Math.max(e.camera.minRadius,Math.min(e.camera.maxRadius,t.radius))),t.yaw!=null&&(e.camera.yaw=t.yaw),t.pitch!=null&&(e.camera.pitch=t.pitch),t.targetX!=null&&(e.camera.target[0]=t.targetX),t.targetY!=null&&(e.camera.target[1]=t.targetY),t.targetZ!=null&&(e.camera.target[2]=t.targetZ)}function ke(e){const t=e.cameraConfig;t&&(t.radiusScale!=null&&(e.camera.radius*=t.radiusScale,e.camera.radius=Math.max(e.camera.minRadius,Math.min(e.camera.maxRadius,e.camera.radius))),t.radius!=null&&(e.camera.radius=Math.max(e.camera.minRadius,Math.min(e.camera.maxRadius,t.radius))))}function ue(e,t,r){const n=t.lightSources||[];if(!n.length){console.log("[Scene][DebugLights]",e,"no lights");return}let i=0,o=0,c=0;for(const a of n){const l=r[0]-a.position[0],s=r[1]-a.position[1],u=r[2]-a.position[2],d=l*l+s*s+u*u,f=Math.sqrt(d);if(f<=0)continue;const b=[-l/f,-s/f,-u/f],g=a.spot[0]-a.position[0],h=a.spot[1]-a.position[1],v=a.spot[2]-a.position[2],w=Math.sqrt(g*g+h*h+v*v)||1,U=[g/w,h/w,v/w],M=-(b[0]*U[0]+b[1]*U[1]+b[2]*U[2])-a.angle;if(M<=0)continue;i++;const L=M/d,B=a.intensity*L;o+=B,B>c&&(c=B)}console.log("[Scene][DebugLights]",e,{totalLights:n.length,inCone:i,sumContribution:o,maxContribution:c})}function Ze(e){const t=j(e.meshes);if(!t)return;const r=[.5*(t.minX+t.maxX),.5*(t.minY+t.maxY),.5*(t.minZ+t.maxZ)],n=[r[0],t.minY+.01,r[2]];ue("center",e,r),ue("ground",e,n)}function $e(e){const t=e.lightSources||[];if(!t.length||typeof document>"u")return;typeof e.baseMeshCount!="number"&&(e.baseMeshCount=e.meshes.length);const r=e.materials.length;e.materials.push({albedo:[1,.9,.2],roughness:.2,metalness:0});const n=.05,i=new Float32Array([-n,0,-n,n,0,-n,0,0,n]),o=new Float32Array([0,1,0,0,1,0,0,1,0]),c=new Uint32Array([0,1,2,0,2,1]);e.debugLightMeshStart=e.meshes.length;for(const a of t){const[l,s,u]=a.position,d=i.length/3,f=new Float32Array(i.length);for(let h=0;h<d;h++){const v=i[3*h],w=i[3*h+1],U=i[3*h+2];f[3*h]=v+l,f[3*h+1]=w+s-.03,f[3*h+2]=U+u}const b=new Float32Array(o.length);b.set(o);const g=new Uint32Array(c.length);g.set(c),e.meshes.push({positions:f,normals:b,indices:g,materialIndex:r})}console.log("[Scene] Added debug light meshes:",e.meshes.length-(e.baseMeshCount??0))}function Je(e){const t=j(e);if(!t)return null;const r=[.5*(t.minX+t.maxX),.5*(t.minY+t.maxY),.5*(t.minZ+t.maxZ)];let n=0;for(const o of e){if(!o.positions||o.positions.length<3)continue;const c=o.positions;for(let a=0;a<c.length;a+=3){const l=c[a]-r[0],s=c[a+1]-r[1],u=c[a+2]-r[2],d=l*l+s*s+u*u;d>n&&(n=d)}}const i=Math.max(Math.sqrt(n),.1);return{center:r,radius:i}}function We(e){const t=Je(e.meshes);if(!t)return;const{center:r,radius:n}=t;e.camera.target=r,e.camera.radius=Math.min(Math.max(n*2.5,e.camera.minRadius*2),e.camera.maxRadius),e.camera.pitch=Math.random()*(Math.PI/2),e.camera.yaw=Math.random()*2*Math.PI,ke(e)}async function de(e,t="ram"){console.log("[Scene] createScene start, aspect =",e,"sceneName =",t);const r={camera:Oe(e),meshes:[],materials:[],lightSources:[]};r.materials=await Ye(t);const n=Math.max(r.materials.length-1,0),i=await Ve(t,n),o=i.meshes||[];let c=i.lights||[];r.meshes=o,r.baseMeshCount=o.length,r.lightSources=[];const a=j(r.meshes);try{const s=await Ne(t,"lights");s&&s.length>0&&(console.log("[Scene] Using lights from separate OBJ file for scene",t),c=s)}catch(s){console.warn("[Scene] Failed to load separate lights OBJ for scene",t,s)}if(t==="ram"&&c.length>0&&a){const s=.5*(a.minX+a.maxX),u=.5*(a.minZ+a.maxZ),d=.5*(a.minY+a.maxY),f=[1,.95,.9],b=.5,g=.05;let h=0;for(const v of c)r.lightSources.push({position:[v[0],v[1],v[2]],intensity:g,color:f,spot:[s,d,u],angle:b,useRaytracedShadows:!0}),h++;console.log("[Scene] Added RAM OBJ lights from RamLight faces:",h,"total lights =",r.lightSources.length)}else if(a){const s=[.5*(a.minX+a.maxX),.5*(a.minY+a.maxY),.5*(a.minZ+a.maxZ)],u=a.maxY+(a.maxY-a.minY)*.6;r.lightSources.push({position:[s[0],u,s[2]],intensity:1,color:[1,1,1],spot:s,angle:.5,useRaytracedShadows:!0}),console.log("[Scene] Added fallback light above scene center, total lights =",r.lightSources.length)}qe(r);const l=await ze(t);return l?(r.cameraConfig=l,Xe(r,l),console.log("[Scene] Applied camera config from camera.txt")):r.cameraConfig=null,$e(r),r.time=0,Ze(r),console.log("[Scene] Scene created:",{camera:r.camera,numMeshes:r.meshes.length,numLights:r.lightSources.length,numMaterials:r.materials.length}),r}function N(e,t,r){const n=e.createBuffer({size:t.byteLength+3&-4,usage:r});return e.queue.writeBuffer(n,0,t),n}function Se(e,t){let r=0,n=0,i=0;for(const f of t)r+=f.positions.length,n+=f.normals.length,i+=f.indices.length;const o=new Float32Array(r),c=new Float32Array(n),a=new Uint32Array(i),l=new Uint32Array(4*t.length);let s=0,u=0,d=0;for(let f=0;f<t.length;f++){const b=t[f],g=4*f;o.set(b.positions,s),l[g]=s/3,s+=b.positions.length,c.set(b.normals,u),u+=b.normals.length,a.set(b.indices,d),l[g+1]=d/3,l[g+2]=b.indices.length/3,d+=b.indices.length,l[g+3]=b.materialIndex??0}return{positionBuffer:N(e.device,o,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),normalBuffer:N(e.device,c,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),indexBuffer:N(e.device,a,GPUBufferUsage.INDEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),meshBuffer:N(e.device,l,GPUBufferUsage.INDEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),indexFormat:"uint32"}}function xe(e,t){for(let n=0;n<t.length;n++){const i=t[n],o=n*8;e.materialStagingBuffer.set(i.albedo,o),e.materialStagingBuffer[o+3]=i.roughness,e.materialStagingBuffer[o+4]=i.metalness}}function we(e,t){return e.materialStagingBuffer=new Float32Array(t.length*8),xe(e,t),N(e.device,e.materialStagingBuffer,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}function H(e,t){xe(e,t),e.device.queue.writeBuffer(e.materialBuffer,0,e.materialStagingBuffer)}function Be(e,t){const n=document.getElementById("rendering_type_select"),i=n?n.value:"raytrace",o=i==="raytrace"||i==="lightcuts",c=2,a=Math.max(1,t.length),l=o?c/a:1;for(let s=0;s<t.length;s++){const u=t[s],d=s*12;e.lightSourceStagingBuffer.set(u.position,d),e.lightSourceStagingBuffer[d+3]=o?l:u.intensity,e.lightSourceStagingBuffer.set(u.color,d+4),e.lightSourceStagingBuffer[d+7]=u.angle,e.lightSourceStagingBuffer.set(u.spot,d+8),e.lightSourceStagingBuffer[d+11]=o?1:0}}function Me(e,t){return e.lightSourceStagingBuffer=new Float32Array(t.length*12),Be(e,t),N(e.device,e.lightSourceStagingBuffer,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}function K(e,t){Be(e,t),e.device.queue.writeBuffer(e.lightSourceBuffer,0,e.lightSourceStagingBuffer)}function fe(e,t){e.meshBuffers=Se(e,t.meshes),e.materialBuffer=we(e,t.materials),e.lightSourceBuffer=Me(e,t.lightSources),e.uniformBuffer=N(e.device,e.uniformData,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),e.debugUniformBuffer=N(e.device,e.debugUniformData,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),e.bindGroup=e.device.createBindGroup({layout:e.bindGroupLayout,entries:[{binding:0,resource:{buffer:e.uniformBuffer}},{binding:1,resource:{buffer:e.meshBuffers.positionBuffer}},{binding:2,resource:{buffer:e.meshBuffers.normalBuffer}},{binding:3,resource:{buffer:e.meshBuffers.indexBuffer}},{binding:4,resource:{buffer:e.meshBuffers.meshBuffer}},{binding:5,resource:{buffer:e.materialBuffer}},{binding:6,resource:{buffer:e.lightSourceBuffer}},{binding:7,resource:{buffer:e.debugUniformBuffer}}]})}function je(e,t){console.log("[GPU] Creating shader module, code length =",t.length),e.shaderModule=e.device.createShaderModule({label:"Shaders",code:t}),e.bindGroupLayout=e.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:5,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:7,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),e.rasterizationPipeline=e.device.createRenderPipeline({label:"rasterizationPipeline",layout:e.device.createPipelineLayout({bindGroupLayouts:[e.bindGroupLayout]}),vertex:{module:e.shaderModule,entryPoint:"rasterVertexMain"},fragment:{module:e.shaderModule,entryPoint:"rasterFragmentMain",targets:[{format:e.canvasFormat}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}),e.depthTexture=e.device.createTexture({size:[e.canvas.width,e.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),e.offscreenColorTexture=e.device.createTexture({label:"RT offscreen color",size:[e.canvas.width,e.canvas.height,1],format:e.canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e.blitBindGroupLayout=e.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),e.blitPipeline=e.device.createRenderPipeline({label:"blitPipeline",layout:e.device.createPipelineLayout({bindGroupLayouts:[e.blitBindGroupLayout]}),vertex:{module:e.shaderModule,entryPoint:"blitVertexMain"},fragment:{module:e.shaderModule,entryPoint:"blitFragmentMain",targets:[{format:e.canvasFormat}]},primitive:{topology:"triangle-list"}}),e.blitSampler=e.device.createSampler({minFilter:"linear",magFilter:"linear"}),e.blitBindGroup=e.device.createBindGroup({layout:e.blitBindGroupLayout,entries:[{binding:0,resource:e.offscreenColorTexture.createView()},{binding:1,resource:e.blitSampler}]}),e.rayTracingPipeline=e.device.createRenderPipeline({label:"rayTracingPipeline",layout:e.device.createPipelineLayout({bindGroupLayouts:[e.bindGroupLayout]}),vertex:{module:e.shaderModule,entryPoint:"rayVertexMain"},fragment:{module:e.shaderModule,entryPoint:"rayFragmentMain",targets:[{format:e.canvasFormat}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}),console.log("[GPU] Pipelines and depth texture created")}function He(e){const t=e.canvas.width,r=e.canvas.height;e.accumTexture=e.device.createTexture({label:"Accumulation color",size:[t,r,1],format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=e.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]});e.accumBlitPipeline=e.device.createRenderPipeline({label:"accumBlitPipeline",layout:e.device.createPipelineLayout({bindGroupLayouts:[n]}),vertex:{module:e.shaderModule,entryPoint:"accumBlitVertexMain"},fragment:{module:e.shaderModule,entryPoint:"accumBlitFragmentMain",targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one",operation:"add"}}}]},primitive:{topology:"triangle-list"}});const i=e.device.createSampler({minFilter:"linear",magFilter:"linear"});e.accumBlitBindGroup=e.device.createBindGroup({layout:n,entries:[{binding:0,resource:e.offscreenColorTexture.createView()},{binding:1,resource:i}]});const o=e.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]});e.accumFinalPipeline=e.device.createRenderPipeline({label:"accumFinalPipeline",layout:e.device.createPipelineLayout({bindGroupLayouts:[o]}),vertex:{module:e.shaderModule,entryPoint:"accumFinalVertexMain"},fragment:{module:e.shaderModule,entryPoint:"accumFinalFragmentMain",targets:[{format:e.canvasFormat}]},primitive:{topology:"triangle-list"}}),e.accumFinalUniformData=new Float32Array(8),e.accumFinalUniformBuffer=e.device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),e.accumFinalBindGroup=e.device.createBindGroup({layout:o,entries:[{binding:0,resource:e.accumTexture.createView()},{binding:1,resource:i},{binding:2,resource:{buffer:e.accumFinalUniformBuffer}}]}),console.log("[GPU] Accumulation resources created")}function Ke(e,t){e.accumFinalUniformData[0]=1/Math.max(1,t),e.device.queue.writeBuffer(e.accumFinalUniformBuffer,0,e.accumFinalUniformData)}async function Qe(){if(!navigator.gpu)throw console.error("[GPU] navigator.gpu not available"),new Error("WebGPU not supported on this browser.");const e=document.querySelector("canvas");console.log("[GPU] Canvas size:",e.width,"x",e.height);const t=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!t)throw console.error("[GPU] requestAdapter() returned null"),new Error("No appropriate GPUAdapter found.");console.log("[GPU] Adapter acquired:",t);const r=await t.requestDevice();console.log("[GPU] Device acquired");const n=e.getContext("webgpu"),i=navigator.gpu.getPreferredCanvasFormat();return n.configure({device:r,format:i,alphaMode:"opaque"}),console.log("[GPU] Context configured with format",i),{canvas:e,adapter:t,device:r,context:n,canvasFormat:i,uniformData:new Float32Array(96),debugUniformData:new Uint32Array(8)}}function Q(e,t){ae(t.camera),e.uniformData.set(t.camera.modelMat,0),e.uniformData.set(t.camera.viewMat,16);const r=oe(t.camera.viewMat);e.uniformData.set(r,32),e.uniformData.set(re(r),48),e.uniformData.set(t.camera.projMat,64),e.uniformData[80]=t.camera.fov,e.uniformData[81]=t.camera.aspect;const n=typeof t.baseMeshCount=="number"?t.baseMeshCount:t.meshes.length;e.uniformData[84]=n,e.uniformData[85]=t.lightSources.length,e.uniformData[86]=0,e.uniformData[87]=t.lightSources.length,e.uniformData[88]=e.canvas.width,e.uniformData[89]=e.canvas.height,e.device.queue.writeBuffer(e.uniformBuffer,0,e.uniformData.buffer,e.uniformData.byteOffset,e.uniformData.byteLength)}function et(e,t,r){e.uniformData[86]=t,e.uniformData[87]=r,e.device.queue.writeBuffer(e.uniformBuffer,344,e.uniformData.buffer,e.uniformData.byteOffset+344,8)}function ee(e){e.debugUniformData[0]=0,e.device.queue.writeBuffer(e.debugUniformBuffer,0,e.debugUniformData)}function Pe(e,t){return[Math.min(e[0],t[0]),Math.min(e[1],t[1]),Math.min(e[2],t[2])]}function Te(e,t){return[Math.max(e[0],t[0]),Math.max(e[1],t[1]),Math.max(e[2],t[2])]}function tt(e,t){const r=e[0]-t[0],n=e[1]-t[1],i=e[2]-t[2];return r*r+n*n+i*i}function Ee(e,t){return{min:Pe(e.min,t.min),max:Te(e.max,t.max)}}function nt(e){return{min:[e[0],e[1],e[2]],max:[e[0],e[1],e[2]]}}function me(e,t){const r=tt(e.representative.position,t.representative.position),n=Ee(e.aabb,t.aabb),i=n.max[0]-n.min[0],o=n.max[1]-n.min[1],c=n.max[2]-n.min[2],a=i*o*c;return r+a}function ne(e,t){return{aabb:nt(e.position),representative:{position:[...e.position],intensity:e.intensity,color:[...e.color]},totalIntensity:e.intensity,left:null,right:null,depth:0,lightCount:1,lightIndex:t}}function Ue(e,t){const r=Ee(e.aabb,t.aabb),n=e.totalIntensity+t.totalIntensity,i=e.totalIntensity/(n||1),o=t.totalIntensity/(n||1),c={position:[e.representative.position[0]*i+t.representative.position[0]*o,e.representative.position[1]*i+t.representative.position[1]*o,e.representative.position[2]*i+t.representative.position[2]*o],intensity:n,color:[e.representative.color[0]*i+t.representative.color[0]*o,e.representative.color[1]*i+t.representative.color[1]*o,e.representative.color[2]*i+t.representative.color[2]*o]};return{aabb:r,representative:c,totalIntensity:n,left:e,right:t,depth:0,lightCount:e.lightCount+t.lightCount,lightIndex:-1}}function W(e,t){e&&(e.depth=t,W(e.left,t+1),W(e.right,t+1))}function ie(e){return e?!e.left&&!e.right?e.depth:Math.max(ie(e.left),ie(e.right)):-1}function it(e){if(!e||e.length===0)return null;if(e.length===1){const n=ne(e[0],0);return n.depth=0,n}const t=e.map((n,i)=>ne(n,i));for(;t.length>1;){let n=0,i=1,o=me(t[0],t[1]);for(let a=0;a<t.length;a++)for(let l=a+1;l<t.length;l++){const s=me(t[a],t[l]);s<o&&(o=s,n=a,i=l)}const c=Ue(t[n],t[i]);t.splice(i,1),t.splice(n,1),t.push(c)}const r=t[0];return W(r,0),r}function ge(e,t="spatial"){if(!e||e.length===0)return null;const r=e.map((c,a)=>({light:c,index:a})),n=t==="spatial";function i(c){if(c.length===0)return null;if(c.length===1)return ne(c[0].light,c[0].index);let a=[1/0,1/0,1/0],l=[-1/0,-1/0,-1/0];for(const b of c){const g=b.light.position;a=Pe(a,g),l=Te(l,g)}const s=[l[0]-a[0],l[1]-a[1],l[2]-a[2]];let u=0;s[1]>s[u]&&(u=1),s[2]>s[u]&&(u=2);let d,f;if(n){const b=(a[u]+l[u])/2,g=[],h=[];for(const v of c)v.light.position[u]<b?g.push(v):h.push(v);d=i(g),f=i(h)}else{c.sort((g,h)=>g.light.position[u]-h.light.position[u]);const b=Math.floor(c.length/2);d=i(c.slice(0,b)),f=i(c.slice(b))}return d?f?Ue(d,f):d:f}const o=i(r);return o&&W(o,0),o}function rt(e,t){const r=[];if(!e)return r;function n(i){if(i){if(i.depth===t){r.push(i);return}if(!i.left&&!i.right){r.push(i);return}n(i.left),n(i.right)}}return n(e),r}function he(e){return ie(e)}const Ge=.02;function ot(e,t,r=Ge){const n=e.min[0]-r,i=e.min[1]-r,o=e.min[2]-r,c=e.max[0]+r,a=e.max[1]+r,l=e.max[2]+r,s=new Float32Array([n,i,o,c,i,o,c,a,o,n,a,o,n,i,l,c,i,l,c,a,l,n,a,l,n,a,o,c,a,o,c,a,l,n,a,l,n,i,o,c,i,o,c,i,l,n,i,l,c,i,o,c,a,o,c,a,l,c,i,l,n,i,o,n,a,o,n,a,l,n,i,l]),u=new Float32Array([0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),d=new Uint32Array([0,1,2,0,2,3,0,2,1,0,3,2,4,6,5,4,7,6,4,5,6,4,6,7,8,9,10,8,10,11,8,10,9,8,11,10,12,14,13,12,15,14,12,13,14,12,14,15,16,17,18,16,18,19,16,18,17,16,19,18,20,22,21,20,23,22,20,21,22,20,22,23]);return{positions:s,normals:u,indices:d,materialIndex:t}}function at(e,t,r=Ge){const n=[];for(let i=0;i<e.length;i++)n.push(ot(e[i].aabb,t+i,r));return n}function st(e){if(e.length===0)return[];let t=1/0,r=-1/0;for(const o of e){const c=o.totalIntensity||0;c<t&&(t=c),c>r&&(r=c)}const n=r-t,i=[];for(const o of e){const c=o.totalIntensity||0,a=n>1e-8?(c-t)/n:.5;let l,s,u;if(a<.5){const d=a*2;l=.9,s=.2+.7*d,u=.1}else l=.9-.7*((a-.5)*2),s=.9,u=.1;i.push({albedo:[l,s,u],roughness:.3,metalness:0})}return i}const ct=128e3,J=10;function lt(){const e=document.getElementById("panel-full-lights");if(e&&!e.hidden&&e.classList.contains("active")){const r=document.getElementById("render_method_select_training");return r?r.value:"tiles"}const t=document.getElementById("render_method_select");return t?t.value:"tiles"}function Le(){const e=document.getElementById("rendering_type_select");return e?e.value:"raytrace"}function k(){const e=Le();return e==="raytrace"||e==="lightcuts"}function ut(e){return e.toDataURL("image/png")}async function dt(e,t,r,n={}){const{onImage:i=()=>{},forceRayTracing:o=!0}=n;console.log("[FullLights] runFullLightsTraining started, numImages =",r);const c=document.getElementById("rendering_type_select"),a=Le();o&&c&&(c.value="raytrace");const l=[];for(let s=0;s<r;s++){We(t);const u=await Z(e,t);l.push(u);const d=ut(e.canvas);i(s,d,u)}return o&&c&&(c.value=a),{times:l}}function ft(e,t,r){e.canvas.addEventListener("mousedown",n=>{t.camera.lastX=n.clientX,t.camera.lastY=n.clientY,n.button===0&&(t.camera.dragging=!0),(n.button===1||n.button===2)&&(t.camera.panning=!0)}),window.addEventListener("mouseup",()=>{t.camera.dragging=!1,t.camera.panning=!1}),e.canvas.addEventListener("mousemove",n=>{const i=n.clientX-(t.camera.lastX??0),o=n.clientY-(t.camera.lastY??0);if(t.camera.lastX=n.clientX,t.camera.lastY=n.clientY,t.camera.dragging){t.camera.yaw-=i*t.camera.rotateSpeed,t.camera.pitch+=o*t.camera.rotateSpeed;const c=Math.PI/2-.01;t.camera.pitch=Math.max(-c,Math.min(c,t.camera.pitch)),r()}t.camera.panning&&(be(t.camera,i,-o),r())}),e.canvas.addEventListener("wheel",n=>{n.preventDefault(),t.camera.radius*=1+n.deltaY*t.camera.zoomSpeed,t.camera.radius=Math.max(t.camera.minRadius,Math.min(t.camera.maxRadius,t.camera.radius)),r()},{passive:!1}),e.canvas.addEventListener("contextmenu",n=>n.preventDefault())}async function Z(e,t){const r=k(),n=lt();return r?n==="accumulation"?bt(e,t):n==="oneshot"?gt(e,t):ht(e,t):mt(e,t)}async function mt(e,t){const r=performance.now();Q(e,t),ee(e),H(e,t.materials),K(e,t.lightSources);const n=e.device.createCommandEncoder(),i=n.beginRenderPass({label:"Raster pass",colorAttachments:[{view:e.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}],depthStencilAttachment:{view:e.depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});i.setPipeline(e.rasterizationPipeline),i.setBindGroup(0,e.bindGroup);for(let l=0;l<t.meshes.length;l++)i.draw(t.meshes[l].indices.length,1,0,l);i.end(),e.device.queue.submit([n.finish()]),await e.device.queue.onSubmittedWorkDone();const c=performance.now()-r,a=document.getElementById("render_time_label");return a&&(a.textContent=`${c.toFixed(3)} ms`),c}async function gt(e,t){const r=performance.now();console.log("[Render] Starting image (one-shot RT)",t.lightSources?.length??0,"lights"),Q(e,t),ee(e),H(e,t.materials),K(e,t.lightSources);const n=e.offscreenColorTexture.createView(),i=e.depthTexture.createView(),o=e.device.createCommandEncoder(),c=o.beginRenderPass({label:"One-shot RT",colorAttachments:[{view:n,loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}],depthStencilAttachment:{view:i,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});c.setPipeline(e.rayTracingPipeline),c.setBindGroup(0,e.bindGroup),c.draw(6),c.end(),e.device.queue.submit([o.finish()]),await e.device.queue.onSubmittedWorkDone();const a=e.device.createCommandEncoder(),l=a.beginRenderPass({label:"Blit to canvas",colorAttachments:[{view:e.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});l.setPipeline(e.blitPipeline),l.setBindGroup(0,e.blitBindGroup),l.draw(6),l.end(),e.device.queue.submit([a.finish()]),await e.device.queue.onSubmittedWorkDone();const u=performance.now()-r;console.log("[Render] One-shot frame in",u.toFixed(3),"ms");const d=document.getElementById("render_time_label");return d&&(d.textContent=`${u.toFixed(3)} ms`),u}async function ht(e,t){const r=performance.now();console.log("[Render] Starting image (tiled RT)",t.lightSources?.length??0,"lights"),Q(e,t),ee(e),H(e,t.materials),K(e,t.lightSources);const n=Math.max(1,t.lightSources?.length??1),i=ct/n,o=Number.isFinite(i)&&i>0?i:t.cameraConfig&&typeof t.cameraConfig.tileSize=="number"?t.cameraConfig.tileSize:256,c=Math.max(32,Math.min(256,Math.round(o))),a=Math.ceil(e.canvas.width/c),l=Math.ceil(e.canvas.height/c),s=a*l,u=e.offscreenColorTexture.createView(),d=e.depthTexture.createView(),f=e.device.createCommandEncoder();f.beginRenderPass({label:"Clear pass",colorAttachments:[{view:u,loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}],depthStencilAttachment:{view:d,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}}).end(),e.device.queue.submit([f.finish()]),await e.device.queue.onSubmittedWorkDone();const g=[];for(let M=0;M<l;M++)for(let L=0;L<a;L++){const B=performance.now(),G=L*c,F=M*c,O=Math.min(c,e.canvas.width-G),_=Math.min(c,e.canvas.height-F),I=e.device.createCommandEncoder(),A=I.beginRenderPass({label:`Tile ${L},${M}`,colorAttachments:[{view:u,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:d,depthLoadOp:"load",depthStoreOp:"store"}});A.setPipeline(e.rayTracingPipeline),A.setBindGroup(0,e.bindGroup),A.setViewport(G,F,O,_,0,1),A.setScissorRect(G,F,O,_),A.draw(6),A.end(),e.device.queue.submit([I.finish()]),await e.device.queue.onSubmittedWorkDone();{const C=performance.now();g.push(C-B)}(L+M*a)%10===0&&await new Promise(C=>setTimeout(C,0))}const h=e.device.createCommandEncoder(),v=h.beginRenderPass({label:"Blit to canvas",colorAttachments:[{view:e.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});if(v.setPipeline(e.blitPipeline),v.setBindGroup(0,e.blitBindGroup),v.draw(6),v.end(),e.device.queue.submit([h.finish()]),await e.device.queue.onSubmittedWorkDone(),g.length>0){const M=g.reduce((G,F)=>G+F,0),L=M/s;let B=0;for(let G=0;G<s;G++){const F=(g[G]??0)-L;B+=F*F}B/=s,console.log("[Render][Tiles] total time =",M.toFixed(3),"ms, tiles =",s,", mean =",L.toFixed(3),"ms, variance =",B.toFixed(3),"ms^2")}const U=performance.now()-r;console.log("[Render] Tiled frame in",U.toFixed(3),"ms");const R=document.getElementById("render_time_label");return R&&(R.textContent=`${U.toFixed(3)} ms`),U}async function bt(e,t){const r=performance.now(),n=t.lightSources?.length??0,i=Math.max(1,Math.ceil(n/J));console.log("[Render] Starting accumulation RT:",n,"lights,",i,"passes of",J),Q(e,t),ee(e),H(e,t.materials),K(e,t.lightSources);const o=e.offscreenColorTexture.createView(),c=e.depthTexture.createView(),a=e.accumTexture.createView();{const d=e.device.createCommandEncoder();d.beginRenderPass({label:"Clear accum",colorAttachments:[{view:a,loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0},storeOp:"store"}]}).end(),e.device.queue.submit([d.finish()]),await e.device.queue.onSubmittedWorkDone()}for(let d=0;d<i;d++){const f=d*J,b=Math.min(f+J,n);et(e,f,b);{const g=e.device.createCommandEncoder(),h=g.beginRenderPass({label:`Accum pass ${d}`,colorAttachments:[{view:o,loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}],depthStencilAttachment:{view:c,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});h.setPipeline(e.rayTracingPipeline),h.setBindGroup(0,e.bindGroup),h.draw(6),h.end(),e.device.queue.submit([g.finish()]),await e.device.queue.onSubmittedWorkDone()}{const g=e.device.createCommandEncoder(),h=g.beginRenderPass({label:`Accum blit ${d}`,colorAttachments:[{view:a,loadOp:"load",storeOp:"store"}]});h.setPipeline(e.accumBlitPipeline),h.setBindGroup(0,e.accumBlitBindGroup),h.draw(6),h.end(),e.device.queue.submit([g.finish()]),await e.device.queue.onSubmittedWorkDone()}d%5===4&&await new Promise(g=>setTimeout(g,0))}Ke(e,i);{const d=e.device.createCommandEncoder(),f=d.beginRenderPass({label:"Accum final blit",colorAttachments:[{view:e.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});f.setPipeline(e.accumFinalPipeline),f.setBindGroup(0,e.accumFinalBindGroup),f.draw(6),f.end(),e.device.queue.submit([d.finish()]),await e.device.queue.onSubmittedWorkDone()}const s=performance.now()-r;console.log("[Render] Accumulation frame in",s.toFixed(3),"ms (",i,"passes)");const u=document.getElementById("render_time_label");return u&&(u.textContent=`${s.toFixed(3)} ms`),s}async function yt(){console.log("[Main] Starting application");try{let e=function(){!k()&&!d&&(u||f())},t=function(){const y=k();!y&&!u?f():y&&u&&(cancelAnimationFrame(u),u=null)},r=function(y,m){const T={camera:y.camera,meshes:[...y.meshes.slice(0,y.baseMeshCount??y.meshes.length)],materials:[...y.materials],lightSources:[],baseMeshCount:y.baseMeshCount??y.meshes.length},S={minX:1/0,minY:1/0,minZ:1/0,maxX:-1/0,maxY:-1/0,maxZ:-1/0};for(const D of T.meshes)if(D.positions)for(let q=0;q<D.positions.length;q+=3)S.minX=Math.min(S.minX,D.positions[q]),S.minY=Math.min(S.minY,D.positions[q+1]),S.minZ=Math.min(S.minZ,D.positions[q+2]),S.maxX=Math.max(S.maxX,D.positions[q]),S.maxY=Math.max(S.maxY,D.positions[q+1]),S.maxZ=Math.max(S.maxZ,D.positions[q+2]);const E=(S.minX+S.maxX)*.5,x=(S.minY+S.maxY)*.5,p=(S.minZ+S.maxZ)*.5,Y=Math.max(S.maxX-S.minX,S.maxY-S.minY,S.maxZ-S.minZ)*1.5,$=[E,x,p],V=D=>({position:D,intensity:.3,color:[1,1,1],spot:$,angle:0,useRaytracedShadows:!1});T.lightSources=[V([E,x+Y,p]),V([E,x-Y,p]),V([E+Y,x,p]),V([E-Y,x,p]),V([E,x,p+Y]),V([E,x,p-Y])];const X=T.materials.length,Re=st(m);for(const D of Re)T.materials.push(D);const Fe=at(m,X);for(const D of Fe)T.meshes.push(D);return T};const n=await Qe(),i=n.canvas.width/n.canvas.height;console.log("[Main] Canvas aspect ratio =",i);const o=await fetch("shaders.wgsl");console.log("[Main] shaders.wgsl HTTP status =",o.status);const c=await o.text();je(n,c),He(n);const a=document.getElementById("scene_select"),l=()=>a&&a.value||"ram";let s=await de(i,l());console.log("[Main] Scene ready, meshes:",s.meshes.length,"lights:",s.lightSources.length);let u=null,d=!1;async function f(){if(d)return;k()?u=null:(d=!0,await Z(n,s),d=!1,u=requestAnimationFrame(f))}ft(n,s,e),fe(n,s),console.log("[Main] GPU buffers initialized"),await Z(n,s);const b=document.getElementById("rendering_type_select");b&&b.addEventListener("change",t),k()||f();const g=document.getElementById("render_button");g&&g.addEventListener("click",async()=>{d||(d=!0,await Z(n,s),d=!1)}),a&&a.addEventListener("change",async()=>{u&&(cancelAnimationFrame(u),u=null);const y=l();try{s=await de(i,y),fe(n,s),await Z(n,s),k()||f()}catch(m){console.error("[Main] Scene load failed:",m)}}),document.querySelectorAll(".tab").forEach(y=>{y.addEventListener("click",()=>{const m=y.getAttribute("data-tab");document.querySelectorAll(".tab").forEach(S=>S.classList.remove("active")),y.classList.add("active"),document.querySelectorAll(".tab-panel").forEach(S=>{const E=S,p=E.id.replace("panel-","")===m;E.classList.toggle("active",p),E.hidden=!p});const T=document.getElementById("playground_sidebar");T&&(T.style.display=m==="playground"?"flex":"none")})});const h=document.getElementById("playground_sidebar");let v=null,w=null;async function U(){if(w)return w;const y=document.getElementById("lightcut_canvas");if(!y)return null;const m=y.getContext("webgpu"),T=navigator.gpu.getPreferredCanvasFormat();return m.configure({device:n.device,format:T,alphaMode:"opaque"}),w={canvas:y,device:n.device,context:m,canvasFormat:T,shaderModule:n.shaderModule,bindGroupLayout:n.bindGroupLayout,rasterizationPipeline:n.rasterizationPipeline,depthTexture:n.device.createTexture({size:[y.width,y.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),uniformBuffer:null,debugUniformBuffer:null,uniformData:new Float32Array(96),debugUniformData:new Uint32Array(8),bindGroup:null},w}async function R(y){if(!v){console.warn("[Lightcut] No tree built yet");return}const m=await U();if(!m)return;const T=he(v),S=rt(v,y),E=document.getElementById("lightcut_node_count");E&&(E.textContent=String(S.length));const x=r(s,S),p={device:m.device,materialStagingBuffer:new Float32Array(0),lightSourceStagingBuffer:new Float32Array(0)};m.meshBuffers=Se(p,x.meshes),m.materialBuffer=we(p,x.materials),m.lightSourceBuffer=Me(p,x.lightSources),m.uniformBuffer=N(m.device,m.uniformData,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),m.debugUniformBuffer=N(m.device,m.debugUniformData,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),m.bindGroup=m.device.createBindGroup({layout:m.bindGroupLayout,entries:[{binding:0,resource:{buffer:m.uniformBuffer}},{binding:1,resource:{buffer:m.meshBuffers.positionBuffer}},{binding:2,resource:{buffer:m.meshBuffers.normalBuffer}},{binding:3,resource:{buffer:m.meshBuffers.indexBuffer}},{binding:4,resource:{buffer:m.meshBuffers.meshBuffer}},{binding:5,resource:{buffer:m.materialBuffer}},{binding:6,resource:{buffer:m.lightSourceBuffer}},{binding:7,resource:{buffer:m.debugUniformBuffer}}]}),ae(x.camera),m.uniformData.set(x.camera.modelMat,0),m.uniformData.set(x.camera.viewMat,16);const Y=oe(x.camera.viewMat);m.uniformData.set(Y,32),m.uniformData.set(re(Y),48),m.uniformData.set(x.camera.projMat,64),m.uniformData[80]=x.camera.fov,m.uniformData[81]=x.camera.aspect,m.uniformData[84]=x.meshes.length,m.uniformData[85]=x.lightSources.length,m.uniformData[86]=0,m.uniformData[87]=x.lightSources.length,m.uniformData[88]=m.canvas.width,m.uniformData[89]=m.canvas.height,m.device.queue.writeBuffer(m.uniformBuffer,0,m.uniformData),m.debugUniformData[0]=2,m.device.queue.writeBuffer(m.debugUniformBuffer,0,m.debugUniformData);const $=m.device.createCommandEncoder(),V=$.beginRenderPass({label:"Lightcut raster pass",colorAttachments:[{view:m.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.06,g:.06,b:.07,a:1},storeOp:"store"}],depthStencilAttachment:{view:m.depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});V.setPipeline(m.rasterizationPipeline),V.setBindGroup(0,m.bindGroup);for(let X=0;X<x.meshes.length;X++)V.draw(x.meshes[X].indices.length,1,0,X);V.end(),m.device.queue.submit([$.finish()]),await m.device.queue.onSubmittedWorkDone()}const M=document.getElementById("lightcut_build_btn"),L=document.getElementById("lightcut_method_select"),B=document.getElementById("lightcut_depth_slider"),G=document.getElementById("lightcut_depth_value"),F=document.getElementById("lightcut_max_depth"),O=document.getElementById("lightcut_total_lights"),_=document.getElementById("lightcut_build_time");M&&M.addEventListener("click",async()=>{if(!s.lightSources||s.lightSources.length===0){console.warn("[Lightcut] No lights in scene");return}M.disabled=!0,M.textContent="Building…",await new Promise(E=>setTimeout(E,10));const y=L?L.value:"kdtree-spatial",m=performance.now();y==="kdtree-spatial"?v=ge(s.lightSources,"spatial"):y==="kdtree-median"?v=ge(s.lightSources,"median"):v=it(s.lightSources);const T=performance.now()-m,S=he(v);F&&(F.textContent=String(S)),O&&(O.textContent=String(s.lightSources.length)),_&&(_.textContent=T.toFixed(1)+" ms"),B&&(B.max=String(S),B.value="0",B.disabled=!1),G&&(G.textContent="0"),M.disabled=!1,M.textContent="Build Tree",console.log(`[Lightcut] Built ${y} tree: maxDepth=${S}, lights=${s.lightSources.length}, time=${T.toFixed(1)}ms`),await R(0)}),B&&B.addEventListener("input",async()=>{const y=parseInt(B.value,10);G&&(G.textContent=String(y)),await R(y)});const I=document.getElementById("lightcut_canvas");I&&(I.addEventListener("mousedown",y=>{s.camera.lastX=y.clientX,s.camera.lastY=y.clientY,y.button===0&&(s.camera._lcDragging=!0),(y.button===1||y.button===2)&&(s.camera._lcPanning=!0)}),window.addEventListener("mouseup",()=>{s.camera._lcDragging=!1,s.camera._lcPanning=!1}),I.addEventListener("mousemove",async y=>{const m=y.clientX-(s.camera.lastX??0),T=y.clientY-(s.camera.lastY??0);if(s.camera.lastX=y.clientX,s.camera.lastY=y.clientY,s.camera._lcDragging){s.camera.yaw-=m*s.camera.rotateSpeed,s.camera.pitch+=T*s.camera.rotateSpeed;const S=Math.PI/2-.01;if(s.camera.pitch=Math.max(-S,Math.min(S,s.camera.pitch)),v){const E=parseInt(B?.value||"0",10);await R(E)}}if(s.camera._lcPanning&&(be(s.camera,m,-T),v)){const S=parseInt(B?.value||"0",10);await R(S)}}),I.addEventListener("wheel",async y=>{if(y.preventDefault(),s.camera.radius*=1+y.deltaY*s.camera.zoomSpeed,s.camera.radius=Math.max(s.camera.minRadius,Math.min(s.camera.maxRadius,s.camera.radius)),v){const m=parseInt(B?.value||"0",10);await R(m)}},{passive:!1}),I.addEventListener("contextmenu",y=>y.preventDefault())),h&&(h.style.display="flex");const A=document.getElementById("full_lights_run_btn"),C=document.getElementById("full_lights_num_images"),P=document.getElementById("full_lights_num_images_value"),se=document.getElementById("full_lights_avg_ms"),z=document.getElementById("full_lights_last_run"),te=document.getElementById("full_lights_grid");A&&te&&(C&&P&&(C.addEventListener("input",()=>{P.textContent=C.value}),P.textContent=C.value),A.addEventListener("click",async()=>{if(d){console.log("[FullLights] Ignored click: already rendering");return}const y=Math.max(1,parseInt(C?.value||"10",10));console.log("[FullLights] Starting generation of",y,"images"),u&&(cancelAnimationFrame(u),u=null),d=!0,A.disabled=!0,te.innerHTML="",z&&(z.textContent="Running…");try{const{times:m}=await dt(n,s,y,{onImage(S,E){const x=document.createElement("img");x.src=E,x.alt=`Frame ${S+1}`,x.className="training-thumb",te.appendChild(x)}}),T=m.length?m.reduce((S,E)=>S+E,0)/m.length:0;se&&(se.textContent=T.toFixed(2)),z&&(z.textContent=m.map(S=>S.toFixed(0)+" ms").join(", ")),console.log("[FullLights] Done. Average time:",T.toFixed(2),"ms")}catch(m){console.error("[FullLights] Error:",m),z&&(z.textContent="Error: "+(m.message||String(m)))}finally{d=!1,A.disabled=!1}}))}catch(e){console.error("[Main] Fatal error during initialization:",e)}}yt();</script>
  <style rel="stylesheet" crossorigin>*{box-sizing:border-box}html{overflow:hidden;height:100%}body{margin:0;padding:0;height:100%;overflow:hidden;font-family:system-ui,-apple-system,sans-serif;background:#1a1a1e;color:#e4e4e7;display:flex;flex-direction:column}.app-header{flex-shrink:0;background:#252529;border-bottom:1px solid #3f3f46;padding:.5rem 1rem}.header-row{display:flex;align-items:center;gap:1.5rem}.app-header label[for=scene_select]{font-size:.9rem;color:#a1a1aa}.app-header #scene_select{padding:.35rem .6rem;border-radius:6px;border:1px solid #3f3f46;background:#18181b;color:#e4e4e7;font-size:.9rem}.tabs{display:flex;gap:.25rem}.tabs .tab{padding:.5rem 1rem;border:none;border-radius:6px;background:transparent;color:#a1a1aa;font-size:.9rem;cursor:pointer}.tabs .tab:hover{color:#e4e4e7;background:#3f3f46}.tabs .tab.active{background:#3f3f46;color:#fff}.app-main{flex:1;display:flex;min-height:0;overflow:hidden}.sidebar{width:240px;flex-shrink:0;padding:1rem;background:#252529;border-right:1px solid #3f3f46;display:flex;flex-direction:column;gap:1rem}.sidebar-section{display:flex;flex-direction:column;gap:.35rem}.sidebar-section:has(input[type=checkbox]){flex-direction:row;align-items:center;gap:.5rem}.sidebar-section label{font-size:.85rem;color:#d4d4d8;order:2}.sidebar-section input[type=checkbox]{width:auto;margin:0;flex-shrink:0;order:1}.sidebar-section input[type=range]{width:100%;max-width:200px}.sidebar-section select,.training-controls select{padding:.35rem;border-radius:6px;border:1px solid #3f3f46;background:#18181b;color:#e4e4e7;font-size:.85rem;max-width:200px}.sidebar-section button{padding:.5rem .75rem;border-radius:6px;border:1px solid #3f3f46;background:#3f3f46;color:#e4e4e7;font-size:.9rem;cursor:pointer;align-self:flex-start}.sidebar-section button:hover{background:#52525b}#render_time_label{font-size:.85rem;color:#a1a1aa}.tab-panel{flex:1;padding:1rem;overflow:auto;min-width:0}.tab-panel#panel-playground{padding:0;overflow:hidden;display:flex;align-items:center;justify-content:center}.tab-panel.training-panel{padding:.5rem 1rem;overflow:hidden;display:flex;flex-direction:column;min-height:0}.tab-panel:not(.active){display:none}.tab-panel.active,.tab-panel#panel-playground.active,.tab-panel.training-panel.active{display:flex}.tab-panel[hidden]{display:none!important}.canvas-container{flex:1;display:flex;align-items:center;justify-content:center;min-width:0;min-height:0;padding:0}.canvas-container canvas{max-width:100%;max-height:calc(100vh - 52px);width:auto;height:auto;object-fit:contain;border-radius:0;background:#18181b}.training-content{max-width:800px;flex:1;display:flex;flex-direction:column;min-height:0}.training-content>p{color:#a1a1aa;margin:0 0 .5rem;font-size:.9rem}.training-content button{padding:.5rem 1rem;border-radius:6px;border:none;background:#3b82f6;color:#fff;font-size:.9rem;cursor:pointer;margin-bottom:.5rem;align-self:flex-start}.training-content button:hover:not(:disabled){background:#2563eb}.training-content button:disabled{opacity:.5;cursor:not-allowed}.training-stats{margin-bottom:.5rem;padding:.5rem .75rem;background:#252529;border-radius:8px;border:1px solid #3f3f46}.training-stats p{margin:.15rem 0;font-size:.85rem}.training-stats span{font-weight:600;color:#a5b4fc}.training-controls{display:flex;flex-wrap:wrap;align-items:center;gap:.5rem 1rem;margin-bottom:.5rem}.training-controls label{font-size:.9rem;color:#d4d4d8}.training-controls input[type=range]{width:100px}.training-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:.5rem;margin-top:.5rem;flex:1;min-height:0;overflow:auto;align-content:start}.training-thumb{width:100%;height:auto;aspect-ratio:4/3;object-fit:contain;background:#18181b;border-radius:6px;border:1px solid #3f3f46}.training-canvas-wrap{margin-top:.5rem;flex:1;min-height:0;display:flex;justify-content:center;align-items:flex-start}.training-canvas-wrap canvas{max-width:100%;max-height:min(400px,45vh);width:auto;height:auto;object-fit:contain}.description-container{flex-shrink:0;padding:0 1rem .5rem;text-align:left;font-size:.9rem;color:#71717a}.description-container:empty{display:none}.lightcut-panel{padding:0!important;overflow:hidden!important}.lightcut-panel.active{display:flex!important;flex-direction:row!important}.lightcut-sidebar{width:260px;flex-shrink:0;padding:1rem;background:#252529;border-right:1px solid #3f3f46;display:flex;flex-direction:column;gap:.75rem;overflow-y:auto}.lightcut-title{margin:0 0 .25rem;font-size:1.05rem;font-weight:600;color:#e4e4e7;letter-spacing:.02em}.lightcut-control-group{display:flex;flex-direction:column;gap:.3rem}.lightcut-control-group label{font-size:.85rem;color:#d4d4d8}.lightcut-control-group select{padding:.35rem;border-radius:6px;border:1px solid #3f3f46;background:#18181b;color:#e4e4e7;font-size:.85rem;max-width:200px}.lightcut-control-group button{padding:.5rem 1rem;border-radius:6px;border:none;background:#8b5cf6;color:#fff;font-size:.9rem;font-weight:500;cursor:pointer;align-self:flex-start;transition:background .15s ease}.lightcut-control-group button:hover:not(:disabled){background:#7c3aed}.lightcut-control-group button:disabled{opacity:.5;cursor:not-allowed}.lightcut-control-group input[type=range]{width:100%;max-width:200px;accent-color:#8b5cf6}.lightcut-stats{padding:.5rem .75rem;background:#1e1e22;border-radius:8px;border:1px solid #3f3f46}.lightcut-stats p{margin:.15rem 0;font-size:.82rem;color:#a1a1aa}.lightcut-stats span{font-weight:600;color:#c4b5fd}.lightcut-canvas-area{flex:1;display:flex;align-items:center;justify-content:center;background:#1a1a1e;min-width:0;min-height:0;overflow:hidden}.lightcut-canvas-area canvas{max-width:100%;max-height:calc(100vh - 52px);width:auto;height:auto;object-fit:contain;background:#18181b;border-radius:0}</style>
</head>

<body>
  <header class="app-header">
    <div class="header-row">
      <label for="scene_select">Scene:</label>
      <select id="scene_select">
        <option value="ram" selected>ram</option>
        <option value="sponza">sponza</option>
        <option value="conference">conference</option>
      </select>
      <nav class="tabs" role="tablist">
        <button type="button" class="tab active" data-tab="playground" role="tab"
          aria-selected="true">Playground</button>
        <button type="button" class="tab" data-tab="full-lights" role="tab" aria-selected="false">Full-lights</button>
        <button type="button" class="tab" data-tab="stochastic" role="tab" aria-selected="false">Stochastic</button>
        <button type="button" class="tab" data-tab="lightcut" role="tab" aria-selected="false">Lightcut Tree</button>
      </nav>
    </div>
  </header>

  <main class="app-main">
    <aside class="sidebar" id="playground_sidebar">
      <div class="sidebar-section">
        <label for="rendering_type_select">Rendering type:</label>
        <select id="rendering_type_select">
          <option value="raster" selected>Raster (testing)</option>
          <option value="raytrace">Raytrace Normal</option>
          <option value="lightcuts">Lightcuts</option>
        </select>
      </div>
      <div class="sidebar-section">
        <button type="button" id="render_button">Generate image</button>
        <span id="render_time_label"></span>
      </div>
      <div class="sidebar-section">
        <label for="render_method_select">Render method:</label>
        <select id="render_method_select">
          <option value="tiles" selected>Tiles (Default)</option>
          <option value="oneshot">One Shot</option>
          <option value="accumulation">Accumulation</option>
        </select>
      </div>
    </aside>

    <section class="tab-panel active" id="panel-playground" role="tabpanel">
      <div class="canvas-container">
        <canvas width="1024" height="768"></canvas>
      </div>
    </section>

    <section class="tab-panel training-panel" id="panel-full-lights" role="tabpanel" hidden>
      <div class="training-content">
        <p>Generate images with full lights, one by one; camera is random on the north hemisphere. Images appear as they
          are generated.</p>
        <div class="training-controls">
          <label for="render_method_select_training">Method:</label>
          <select id="render_method_select_training" style="margin-right: 1rem;">
            <option value="tiles" selected>Tiles</option>
            <option value="oneshot">One Shot</option>
            <option value="accumulation">Accumulation</option>
          </select>
          <label for="full_lights_num_images">Number of images:</label>
          <input type="range" id="full_lights_num_images" min="1" max="32" value="10">
          <span id="full_lights_num_images_value">10</span>
          <button type="button" id="full_lights_run_btn">Generate images</button>
        </div>
        <div class="training-stats" id="full_lights_stats">
          <p>Average render time: <span id="full_lights_avg_ms">—</span> ms</p>
          <p>Last run: <span id="full_lights_last_run">—</span></p>
        </div>
        <div class="training-grid" id="full_lights_grid"></div>
      </div>
    </section>

    <section class="tab-panel training-panel" id="panel-stochastic" role="tabpanel" hidden>
      <div class="training-content">
        <p>Stochastic method benchmarks (to be implemented). Same structure as Full-lights: run N images, report average
          time.</p>
        <button type="button" id="stochastic_run_btn" disabled>Run 10 images (coming next)</button>
        <div class="training-stats" id="stochastic_stats">
          <p>Average render time: <span id="stochastic_avg_ms">—</span> ms</p>
          <p>Last run: <span id="stochastic_last_run">—</span></p>
        </div>
      </div>
    </section>

    <section class="tab-panel lightcut-panel" id="panel-lightcut" role="tabpanel" hidden>
      <div class="lightcut-sidebar">
        <h3 class="lightcut-title">Lightcut Tree</h3>
        <div class="lightcut-control-group">
          <label for="lightcut_method_select">Build method:</label>
          <select id="lightcut_method_select">
            <option value="kdtree-spatial" selected>KD-Tree Spatial</option>
            <option value="kdtree-median">KD-Tree Median</option>
          </select>
        </div>
        <div class="lightcut-control-group">
          <button type="button" id="lightcut_build_btn">Build Tree</button>
        </div>
        <div class="lightcut-control-group">
          <label for="lightcut_depth_slider">Depth (rank): <span id="lightcut_depth_value">0</span></label>
          <input type="range" id="lightcut_depth_slider" min="0" max="0" value="0" disabled>
        </div>
        <div class="lightcut-stats" id="lightcut_stats">
          <p>Tree depth: <span id="lightcut_max_depth">—</span></p>
          <p>Nodes at rank: <span id="lightcut_node_count">—</span></p>
          <p>Total lights: <span id="lightcut_total_lights">—</span></p>
          <p>Build time: <span id="lightcut_build_time">—</span></p>
        </div>
      </div>
      <div class="lightcut-canvas-area">
        <canvas id="lightcut_canvas" width="1024" height="768"></canvas>
      </div>
    </section>
  </main>

  <div class="description-container"></div>
</body>

</html>